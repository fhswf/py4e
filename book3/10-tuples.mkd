
Tupeln
======

Tupel sind unveränderbar
------------------------

\index{Tupel}
\index{Datentyp!Tupel}
\index{Folge}

Ein Tupel^[Das Wort „Tupel“ kommt von den Namen, die man Zahlenfolgen unterschiedlicher Länge gibt: einfach, doppelt, dreifach, vierfach, fünffach, sechsfach, siebenfach usw.] ist eine Folge von Werten, ähnlich wie eine Liste. Die in einem Tupel gespeicherten Werte können von beliebigem Typ sein, und sie werden durch Ganzzahlen indiziert. Der wichtige Unterschied ist, dass Tupel *unveränderlich* sind. Tupel sind außerdem *vergleichbar* und können *gehasht* werden, sodass wir Listen von ihnen sortieren und Tupel als Schlüsselwerte in Python-Wörterbüchern verwenden können.

\index{Veränderbarkeit}
\index{vergleichbar}
\index{Unveränderlichkeit}

Syntaktisch ist ein Tupel eine durch Kommata getrennte Liste von Werten:

~~~~ {.python}
>>> t = 'a', 'b', 'c', 'd', 'e'
~~~~

Obwohl es nicht notwendig ist, ist es üblich, Tupel in Klammern einzuschließen, damit wir Tupel schnell identifizieren können, wenn wir uns Python-Code ansehen:

\index{Klammern!Tupeln innerhalb}

~~~~ {.python}
>>> t = ('a', 'b', 'c', 'd', 'e')
~~~~

Um ein Tupel mit einem einzelnen Element zu erstellen, müssen Sie das abschließende Komma einfügen:

\index{Singleton}
\index{Tupel!Singleton}

~~~~ {.python .trinket}
>>> t1 = ('a',)
>>> type(t1)
<type 'tuple'>
~~~~

Ohne das Komma behandelt Python `('a')` als einen Ausdruck mit einer Zeichenkette in Klammern, der zu einer Zeichenkette ausgewertet wird:

~~~~ {.python}
>>> t2 = ('a')
>>> type(t2)
<type 'str'>
~~~~

Eine weitere Möglichkeit, ein Tupel zu konstruieren, ist die eingebaute Funktion `tuple`. Ohne Argument erzeugt sie ein leeres Tupel:

\index{tuple (Funktion)}
\index{Funktion!tuple}

~~~~ {.python .trinket}
>>> t = tuple()
>>> print(t)
()
~~~~

Wenn das Argument eine Sequenz (String, Liste oder Tupel) ist, ist das Ergebnis des Aufrufs von `tuple` ein Tupel mit den Elementen der Sequenz:

~~~~ {.python .trinket}
>>> t = tuple('lupins')
>>> print(t)
('l', 'u', 'p', 'i', 'n', 's')
~~~~

Da `tuple` der Name eines *Konstruktors* ist, sollten Sie es vermeiden, ihn als Variablennamen zu verwenden.

Die meisten Listenoperatoren funktionieren auch auf Tupeln. Der Indexoperator indiziert ein Element:

\index{Indexoperator}\index{Zugriff, indexbasiert}
\index{Operator!indexbasierter Zugriff}

~~~~ {.python .trinket}
>>> t = ('a', 'b', 'c', 'd', 'e')
>>> print(t[0])
'a'
~~~~

Und der Slice-Operator selektiert einen Bereich von Elementen.

\index{slice-Operator}
\index{Operator!slice}
\index{Tupel!slice}
\index{slice!Tupel}

~~~~ {.python}
>>> print(t[1:3])
('b', 'c')
~~~~

Wenn Sie jedoch versuchen, eines der Elemente des Tupels zu ändern, erhalten Sie einen Fehler:

\index{Ausnahme!TypeError}
\index{TypeError}
\index{Elementzuweisung}
\index{Zuweisung!Element}

~~~~ {.python}
>>> t[0] = 'A'
TypeError: object doesn't support item assignment
~~~~

Sie können die Elemente eines Tupels nicht ändern, aber Sie können ein Tupel durch ein anderes ersetzen:

~~~~ {.python .trinket}
>>> t = ('A',) + t[1:]
>>> print(t)
('A', 'b', 'c', 'd', 'e')
~~~~

Vergleichen von Tupeln
----------------------

\index{Vergleich!Tupel}
\index{Tupel!Vergleich}
\index{sort (Methode)}
\index{Methode!sort}

The comparison operators work with tuples and other sequences. Python starts by comparing the first element from each sequence. If they are equal, it goes on to the next element, and so on, until it finds elements that differ. Subsequent elements are not considered (even if they are really big).

Die Vergleichsoperatoren arbeiten mit Tupeln und anderen Sequenzen. Python beginnt mit dem Vergleich des jeweils ersten Elements aus jeder Sequenz. Wenn beide gleich sind, geht es weiter zum nächsten Element und so weiter, bis zwei Elemente gefunden wurden, die sich unterscheiden. Diese werden entsprechend des verwendeten Operators verglichen. Damit endet der Vergleich der Tupeln. Alle danach kommenden Elemente werden also nicht mehr berücksichtigt.

~~~~ {.python .trinket}
>>> (0, 1, 2) < (0, 3, 4)
True
>>> (0, 1, 2000000) < (0, 3, 4)
True
~~~~

Die Funktion `sort` arbeitet auf die gleiche Weise. Sie sortiert primär nach ersten Element, aber im Falle eines Gleichstandes nach dem zweiten Element und und so weiter.

Diese Funktion eignet sich für ein Muster namens *DSU* für

Decorate
:   „Dekorieren“ einer Sequenz, indem eine Liste von Tupeln mit einem oder mehreren Sortierschlüsseln den Elementen der Sequenz vorangestellt werden.

Sort
:   Sortieren der Liste der Tupel mit dem in Python eingebauten `sort`.

Undecorate
:   Extrahieren der sortierten Elemente der Sequenz.

\index{DSU-Muster}
\index{Muster!DSU}
\index{Decorate-Sort-Undecorate-Muster}
\index{Muster!Decorate-Sort-Undecorate}
\index{Romeo and Juliet}

Angenommen, Sie haben eine Liste von Wörtern und möchten diese nach den Wortlängen absteigend sortieren:

\VerbatimInput{../code3/soft.py} 

Die erste Schleife baut eine Liste von Tupeln auf, wobei jedes Tupel ein Wort ist, dem seine Länge vorangestellt ist.

`sort` vergleicht das erste Element (die Länge) zuerst und berücksichtigt nur das zweite Element, um Gleichstände aufzulösen. Das Schlüsselwortargument `reverse=True` sagt `sort`, dass es in absteigender Reihenfolge vorgehen soll.

\index{Schlüsselwortargument}
\index{Argument!Schlüsselwort}
\index{Traversieren}

Die zweite Schleife durchläuft die Liste aller Tupel und baut eine Liste der Wörter nach absteigender Wortlänge auf. Die vier Zeichen langen Wörter werden in *umgekehrter* alphabetischer Reihenfolge sortiert, sodass „what“ in der folgenden Liste vor „soft“ erscheint.

Die Ausgabe des Programms ist wie folgt:

~~~~
['yonder', 'window', 'breaks', 'light', 'what',
'soft', 'but', 'in']
~~~~

Natürlich verliert die Zeile viel von ihrer poetischen Wirkung, wenn man sie in eine Python-Liste verwandelt und in absteigender Reihenfolge der Wortlänge sortiert.

Tupel-Zuweisung
---------------

\index{Tupel!Zuweisung}
\index{Zuweisung!Tupel}
\index{Swap (Muster)}
\index{Muster!Swap}

Eine der einzigartigen syntaktischen Eigenschaften der Sprache Python ist die Fähigkeit, ein Tupel auf der linken Seite einer Zuweisung haben zu können. Dadurch können Sie mehr als eine Variable auf einmal zuweisen, wenn die linke Seite eine Sequenz ist.

In diesem Beispiel haben wir eine zweielementige Liste (die eine Sequenz ist) und weisen das erste und zweite Element der Sequenz den Variablen `x` und `y` in einer einzigen Anweisung zu.

~~~~ {.python .trinket}
>>> m = [ 'have', 'fun' ]
>>> x, y = m
>>> x
'have'
>>> y
'fun'
>>>
~~~~

Es ist keine Magie, Python übersetzt die Tupel-Zuweisungssyntax in etwa so, dass sie wie folgt aussieht:^[Python übersetzt die Syntax nicht wörtlich. Wenn Sie dies zum Beispiel mit einem Wörterbuch versuchen, wird es nicht so funktionieren, wie Sie es vielleicht erwarten.]

~~~~ {.python .trinket}
>>> m = [ 'have', 'fun' ]
>>> x = m[0]
>>> y = m[1]
>>> x
'have'
>>> y
'fun'
>>>
~~~~

Stilistisch gesehen lassen wir die Klammern weg, wenn wir ein Tupel auf der linken Seite der Zuweisungsanweisung verwenden, aber das Folgende ist eine ebenso gültige Schreibweise:

~~~~ {.python}
>>> m = [ 'have', 'fun' ]
>>> (x, y) = m
>>> x
'have'
>>> y
'fun'
>>>
~~~~

Eine besonders clevere Anwendung der Tupel-Zuweisung erlaubt es uns, die Werte zweier Variablen in einer einzigen Anweisung zu *tauschen*:

~~~~ {.python}
>>> a, b = b, a
~~~~

Beide Seiten dieser Anweisung sind Tupel, aber die linke Seite ist ein Tupel von Variablen; die rechte Seite ist ein Tupel von Ausdrücken. Jeder Wert auf der rechten Seite wird der entsprechenden Variablen auf der linken Seite zugewiesen. Alle Ausdrücke auf der rechten Seite werden vor ihrer Zuweisungen ausgewertet.

Die Anzahl der Variablen auf der linken Seite und die Anzahl der Werte auf der rechten Seite müssen gleich sein:

\index{Ausnahme!ValueError}
\index{ValueError}

~~~~ {.python}
>>> a, b = 1, 2, 3
ValueError: too many values to unpack
~~~~

Allgemeiner ausgedrückt, kann die rechte Seite eine beliebige Sequenz (String, Liste oder Tupel) sein. Um z. B. eine E-Mail-Adresse in einen Benutzernamen und eine Domäne aufzuteilen, könnten Sie schreiben:

\index{split (Methode)
\index{Methode!split}
\index{E-Mail-Adresse}

~~~~ {.python}
>>> addr = 'monty@python.org'
>>> uname, domain = addr.split('@')
~~~~

Der Rückgabewert von `split` ist eine Liste mit zwei Elementen; das erste Element wird `uname` zugewiesen, das zweite `domain`.

~~~~ {.python}
>>> print(uname)
monty
>>> print(domain)
python.org
~~~~

Wörterbüchern und Tupel
-----------------------

\index{Wörterbuch}
\index{items (Methode)}
\index{Methode!items}
\index{Key-Value-Paar}\index{Schlüssel-Wert-Paar}

Wörterbücher haben eine Methode namens `items`, die eine Liste von Tupeln zurückgibt, wobei jedes Tupel ein Schlüssel-Wert-Paar ist:

~~~~ {.python .trinket}
>>> d = {'a':10, 'b':1, 'c':22}
>>> t = list(d.items())
>>> print(t)
[('b', 1), ('a', 10), ('c', 22)]
~~~~

Wie Sie es vermutlich von einem Wörterbuch erwarten, sind die Begriffe in keiner bestimmten Reihenfolge angeordnet.

Da die Liste der Tupel jedoch eine Liste ist und Tupel vergleichbar sind, können wir nun die Liste der Tupel sortieren. Das Konvertieren eines Wörterbuchs in eine Liste von Tupeln ist eine Möglichkeit, den Inhalt eines Wörterbuchs nach Schlüssel sortiert auszugeben:

~~~~ {.python}
>>> d = {'a':10, 'b':1, 'c':22}
>>> t = list(d.items())
>>> t
[('b', 1), ('a', 10), ('c', 22)]
>>> t.sort()
>>> t
[('a', 10), ('b', 1), ('c', 22)]
~~~~

Die neue Liste wird in aufsteigender alphabetischer Reihenfolge nach dem Schlüsselwert sortiert.

Mehrfachzuweisung mit Wörterbüchern
-----------------------------------

\index{Traversieren!Wörterbuch}
\index{Wörterbuch!Traversieren}

Durch die Kombination von `items`, Tupel-Zuweisung und `for` können Sie ein schönes Code-Schema für das Durchlaufen der Schlüssel und Werte eines Wörterbuchs in einer einzigen Schleife sehen:

~~~~ {.python}
for key, val in list(d.items()):
    print(val, key)
~~~~

Diese Schleife hat zwei *Iterationsvariablen*, weil `items` eine Liste von Tupeln zurückgibt und `key, val` eine Tupel-Zuweisung ist, die nacheinander durch jedes der Schlüssel-Wert-Paare im Wörterbuch iteriert.

Bei jeder Iteration durch die Schleife werden sowohl `key` als auch `val` zum nächsten Schlüssel-Wert-Paar im Wörterbuch vorgerückt (immer noch in Hash-Reihenfolge).

Der Ausgang dieser Schleife ist:

~~~~
10 a
22 c
1 b
~~~~

Auch hier gilt wieder die Reihenfolge der Hash-Schlüssel (d. h. letztendlich keine bestimmte Reihenfolge).

Wenn wir diese beiden Techniken kombinieren, können wir den Inhalt eines Wörterbuchs sortiert nach dem *Wert*, der in jedem Schlüssel-Wert-Paar gespeichert ist, ausgeben.

Um dies zu tun, erstellen wir zunächst eine Liste von Tupeln, wobei jedes Tupel `(value, key)` ist. Die Methode `items` würde uns eine Liste von `(key, value)`-Tupeln liefern, aber dieses Mal wollen wir nach Wert und nicht nach Schlüssel sortieren. Sobald wir die Liste mit den Wert-Schlüssel-Tupeln aufgebaut haben, ist es eine einfache Sache, die Liste in umgekehrter Reihenfolge zu sortieren und die neue, sortierte Liste auszudrucken.

~~~~ {.python}
>>> d = {'a':10, 'b':1, 'c':22}
>>> l = list()
>>> for key, val in d.items() :
...     l.append( (val, key) )
...
>>> l
[(10, 'a'), (22, 'c'), (1, 'b')]
>>> l.sort(reverse=True)
>>> l
[(22, 'c'), (10, 'a'), (1, 'b')]
>>>
~~~~

Indem wir die Liste der Tupel sorgfältig so konstruieren, dass der Wert das erste Element jedes Tupels ist, können wir die Liste der Tupel sortieren und erhalten unseren Wörterbuchinhalt nach dem Wert sortiert.

Die häufigsten Wörter
---------------------

\index{Romeo and Juliet}

Wenn wir zu unserem laufenden Beispiel des Textes aus *Romeo und Juliet* Akt 2, Szene 2 zurückkehren, können wir unser Programm erweitern, um diese Technik zu verwenden, um die zehn häufigsten Wörter im Text wie folgt auszugeben:

\VerbatimInput{../code3/count3.py} 
\begin{trinketfiles}
../code3/romeo-full.txt
\end{trinketfiles}

Der erste Teil des Programms, der die Datei liest und das Wörterbuch erstellt, welches jedes Wort auf die Anzahl der Wörter im Dokument abbildet, bleibt unverändert. Aber anstatt einfach `counts` auszugeben und das Programm zu beenden, konstruieren wir eine Liste von `(val, key)`-Tupeln und sortieren die Liste dann in umgekehrter Reihenfolge.

Da der Wert an erster Stelle steht, wird er für die Vergleiche verwendet. Wenn es mehr als ein Tupel mit demselben Wert gibt, wird das zweite Element (der Schlüssel) betrachtet, sodass Tupel, bei denen der Wert gleich ist, weiter nach der alphabetischen Reihenfolge des Schlüssels sortiert werden.

Am Ende schreiben wir eine `for`-Schleife, die in jeder Iteration eine Mehrfachzuweisung durchführt und die zehn häufigsten Wörter ausgibt, indem sie durch einen Ausschnitt der Liste (`lst[:10]`) iteriert.

Jetzt sieht die Ausgabe endlich so aus, wie wir es uns für unsere Worthäufigkeitsanalyse wünschen.

~~~~
61 i
42 and
40 romeo
34 to
34 the
32 thou
32 juliet
30 that
29 my
24 thee
~~~~

Die Tatsache, dass dieses komplexe Parsen und Analysieren von Daten mit einem leicht verständlichen 19-zeiligen Python-Programm durchgeführt werden kann, ist ein Grund, warum Python eine gute Wahl als Sprache für die Erforschung von Informationen ist.

Verwendung von Tupeln als Schlüssel in Wörterbüchern
----------------------------------------------------

\index{Tupel!als Schlüssel in Wörterbüchern}
\index{hashbar}

Da Tupel *gehasht* werden können und Listen nicht, müssen wir ein Tupel als Schlüssel verwenden, wenn wir einen *zusammengesetzten* Schlüssel zur Verwendung in einem Wörterbuch erstellen wollen.

Wir würden auf einen zusammengesetzten Schlüssel stoßen, wenn wir ein Telefonverzeichnis erstellen wollten, das von Nachnamen-Vornamen-Paaren auf Telefonnummern abbildet. Unter der Annahme, dass wir die Variablen `last`, `first` und `number` definiert haben, könnten wir eine Wörterbuchzuweisung wie folgt schreiben:

~~~~ {.python}
directory[last,first] = number
~~~~

Der Ausdruck in Klammern ist ein Tupel. Wir könnten die Tupel-Zuweisung in einer `for`-Schleife verwenden, um dieses Wörterbuch zu durchlaufen.

\index{Tupel!geklammert}

~~~~ {.python}
for last, first in directory:
    print(first, last, directory[last,first])
~~~~

Diese Schleife durchläuft die Schlüssel in `directory`, bei denen es sich um Tupel handelt. Sie ordnet die Elemente jedes Tupels `last` und `first` zu und gibt dann den Namen und die entsprechende Telefonnummer aus.

Zeichenketten, Listen und Tupel
-------------------------------

\index{Folge}

Ich habe mich auf Listen von Tupeln konzentriert, aber fast alle Beispiele in diesem Kapitel arbeiten auch mit Listen von Listen, Tupeln von Tupeln und Tupeln von Listen. Um die Aufzählung der möglichen Kombinationen zu vermeiden, ist es manchmal einfacher, von „Sequenzen von Sequenzen“ zu sprechen.

In vielen Kontexten können die verschiedenen Arten von Sequenzen (Strings, Listen und Tupel) austauschbar verwendet werden. Wie und warum wählen Sie also eine der beiden Arten aus?

\index{Zeichenkette}
\index{Liste}
\index{Tupel}
\index{Veränderbarkeit}
\index{Unveränderlichkeit}

Um mit dem Offensichtlichen zu beginnen: Zeichenketten sind begrenzter als andere Sequenzen, da die Elemente Zeichen sein müssen. Außerdem sind sie unveränderlich. Wenn Sie die Möglichkeit benötigen, die Zeichen in einer Zeichenfolge zu ändern (im Gegensatz zur Erstellung einer neuen Zeichenfolge), sollten Sie stattdessen eine Liste von Zeichen verwenden.

Listen sind üblicher als Tupel, hauptsächlich weil sie veränderbar sind. Aber es gibt ein paar Fälle, in denen Sie Tupel bevorzugen könnten:

1.  In manchen Kontexten, wie z. B. einer `return`-Anweisung, ist es syntaktisch einfacher, ein Tupel zu erstellen als eine Liste. In anderen Kontexten bevorzugen Sie vielleicht eine Liste.

2.  Wenn Sie eine Sequenz als Wörterbuchschlüssel verwenden möchten, müssen Sie einen unveränderlichen Typ wie ein Tupel oder einen String verwenden.

3.  Wenn Sie eine Sequenz als Argument an eine Funktion übergeben, verringert die Verwendung von Tupeln das Potenzial für unerwartetes Verhalten aufgrund von Aliasbildung.

Da Tupel unveränderlich sind, bieten sie keine Methoden wie `sort` und `reverse`, die bestehende Listen verändern. Python bietet jedoch die eingebauten Funktionen `sorted` und `reversed`, die eine beliebige Sequenz als Parameter nehmen und eine neue Sequenz mit denselben Elementen in einer anderen Reihenfolge zurückgeben.

\index{sorted (Funktion)}
\index{Funktion!sorted}
\index{reversed (Funktion)}
\index{Funktion!reversed}

Debugging
---------

\index{Debugging}
\index{Datenstruktur}

Listen, Wörterbücher und Tupel sind allgemein als *Datenstrukturen* bekannt; in diesem Kapitel beginnen wir, zusammengesetzte Datenstrukturen zu sehen, wie Listen von Tupeln und Wörterbücher, die Tupel als Schlüssel und Listen als Werte enthalten. Zusammengesetzte Datenstrukturen sind nützlich, aber sie sind anfällig für das, was man als *Formatfehler* bezeichnen könnte; das heißt, Fehler, die entstehen, wenn eine Datenstruktur den falschen Typ, die falsche Größe oder die falsche Zusammensetzung hat, oder wenn Sie vielleicht etwas Code schreiben und das Format Ihrer Daten vergessen und einen Fehler einführen. Wenn Sie zum Beispiel eine Liste mit einer Ganzzahl erwarten und ich Ihnen eine einfache Ganzzahl (nicht in einer Liste) gebe, wird es nicht funktionieren.

Glossar
-------

vergleichbar
:   Ein Datentyp, bei dem ein Wert daraufhin überprüft werden kann, ob er größer, kleiner oder gleich einem anderen Wert desselben Typs ist. Typen, die vergleichbar sind, können in eine Liste eingefügt und sortiert werden.
\index{vergleichbar}

Datenstruktur
:   Eine Sammlung zusammengehöriger Werte, oft organisiert in Listen, Wörterbüchern, Tupeln usw.
\index{Datenstruktur}

DSU
:   Abkürzung für „Decorate-Ssort-Undecorate“, ein Muster, bei dem eine Liste von Tupeln erstellt, sortiert und ein Teil des Ergebnisses extrahiert wird.
\index{DSU-Muster}

hashbar
:   Ein Datentyp, der eine Hash-Funktion hat. Unveränderliche Typen wie Ganzzahlen, Fließkommazahlen und Zeichenketten sind hashfähig; veränderliche Typen wie Listen und Wörterbücher können nicht gehasht werden.
\index{hashbar}

Singleton
:   Eine Liste (oder andere Sequenz) mit einem einzelnen Element.
\index{Singleton}

Tupel
:   Eine unveränderliche Folge von Elementen.
\index{Tupel}

Tupelzuweisung
:   An assignment with a sequence on the right side and a tuple of
    variables on the left. The right side is evaluated and then its
    elements are assigned to the variables on the left.
\index{Tupelzuweisung}
\index{Zuweisung!Tupel}

Übungen
-------

**Übung 1: Überarbeiten Sie ein vorheriges Programm wie folgt: Lesen und parsen Sie die „From“-Zeilen und extrahieren Sie die Adressen aus der Zeile. Zählen Sie mit Hilfe eines Wörterbuchs die Anzahl der Nachrichten von jeder Person.**

**Nachdem alle Daten gelesen wurden, geben Sie die Person mit den meisten Nachrichten aus, indem Sie eine Liste von `(count, email)`-Tupeln aus dem Wörterbuch erstellen. Dann sortieren Sie die Liste in umgekehrter Reihenfolge und geben die Person aus, die die meisten Nachrichten hat.**

~~~~
Sample Line:
From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008

Enter a file name: mbox-short.txt
cwen@iupui.edu 5

Enter a file name: mbox.txt
zqian@umich.edu 195
~~~~

**Übung 2: Schreiben Sie ein Programm, welches die Häufigkeit von Nachrichten pro Tageszeit (ganze Stunden) ermittel. Sie können die Stunde aus der „From“-Zeile extrahieren, indem Sie die Uhrzeit-Zeichenfolge finden und diese Zeichenfolge dann mit anhand des Doppelpunkts in Teile zergliedern. Sobald Sie die Nachrichtenhäufigkeit für jede Stunde gesammelt haben, geben Sie die Häufigkeiten aus, eine pro Zeile, sortiert nach Stunde, wie unten gezeigt.**

~~~~
python timeofday.py
Enter a file name: mbox-short.txt
04 3
06 1
07 1
09 2
10 3
11 6
14 1
15 2
16 4
17 2
18 1
19 1
~~~~

**Übung 3: Schreiben Sie ein Programm, das eine Datei liest und die *Buchstaben* in absteigender Reihenfolge der Häufigkeit ausgibt. Ihr Programm sollte alle Eingaben in Kleinbuchstaben umwandeln und nur die Buchstaben a-z zählen. Ihr Programm sollte keine Leerzeichen, Ziffern, Interpunktionszeichen oder irgendetwas anderes als die Buchstaben a-z zählen. Suchen Sie Textbeispiele aus verschiedenen Sprachen und sehen Sie, wie die Buchstabenhäufigkeit zwischen den Sprachen variiert. Vergleichen Sie Ihre Ergebnisse mit den Tabellen auf <https://wikipedia.org/wiki/Letter_frequencies>.**

\index{Buchstabenhäufigkeit}
\index{Häufigkeit!Buchstaben}

