
Funktionen
==========

Funktionsaufrufe
----------------

\index{Funktionsaufruf}

Im Zusammenhang mit der Programmierung ist eine *Funktion* eine benannte Folge von Anweisungen, die eine Berechnung durchführt. Wenn Sie eine Funktion definieren, geben Sie den Namen und die Abfolge der Anweisungen an. Später können Sie die Funktion mit dem Namen „aufrufen“. Wir haben bereits ein Beispiel für einen *Funktionsaufruf* gesehen:

~~~~ {.python}
>>> type(32)
<class 'int'>
~~~~

Der Name der Funktion ist `type`. Der Ausdruck in Klammern wird das *Argument* der Funktion genannt. Das Argument ist ein Wert oder eine Variable, die wir in die Funktion als Eingabe für die Funktion übergeben. Das Ergebnis ist der Datentyp des Arguments.

\index{Klammern!Argument in}

Es ist üblich zu sagen, dass eine Funktion ein Argument „nimmt“ oder „akzeptiert“ und ein Ergebnis „zurückgibt“. Das Ergebnis wird als *Rückgabewert* bezeichnet.

\index{Argument}
\index{Rückgabewert}

Built-in-Funktionen
-------------------

Python bietet eine Reihe von wichtigen eingebauten Funktionen (Built-in-Funktionen), die wir verwenden können, ohne die Funktionsdefinition angeben zu müssen. Die Schöpfer von Python haben eine Reihe von Funktionen geschrieben, um häufige Probleme zu lösen, und sie in Python integriert, damit wir sie verwenden können.

Die Funktionen `max` und `min` geben uns den größten bzw. kleinsten Wert in einer Liste:

~~~~ {.python}
>>> max('Hello world')
'w'
>>> min('Hello world')
' '
>>>
~~~~

Die Funktion `max` sagt uns das "größte Zeichen" in der Zeichenkette (was sich als der Buchstabe `'w'` herausstellt) und die Funktion `min` zeigt uns das kleinste Zeichen (was sich als ein Leerzeichen herausstellt).

Eine weitere sehr gebräuchliche eingebaute Funktion ist die Funktion `len`, die uns sagt, wie viele Elemente in ihrem Argument enthalten sind. Wenn das Argument von `len` eine Zeichenkette ist, gibt sie die Anzahl der Zeichen in der Zeichenkette zurück.

~~~~ {.python}
>>> len('Hello world')
11
>>>
~~~~

Diese Funktionen sind nicht auf die Verarbeitung von Zeichenketten beschränkt. Sie können mit jeder Menge von Werten arbeiten, wie wir in späteren Kapiteln sehen werden.

Sie sollten die Namen der eingebauten Funktionen wie reservierte Wörter behandeln (d. h. vermeiden Sie die Verwendung von „max“ als Variablenname).

Funktionen zur Typumwandlung
----------------------------

\index{Umwandlung!Datentyp}
\index{Typumwandlung}

Python bietet auch eingebaute Funktionen, die Werte von einem Typ in einen anderen konvertieren. Die Funktion `int` nimmt einen beliebigen Wert und konvertiert ihn in eine Ganzzahl, wenn sie es kann, oder beschwert sich andernfalls:

\index{int Funktion}
\index{Funktion!int}

~~~~ {.python}
>>> int('32')
32
>>> int('Hello')
ValueError: invalid literal for int() with base 10: 'Hello'
~~~~

`int` kann Fließkommawerte in Ganzzahlen umwandeln, rundet aber nicht ab, sondern schneidet den Nachkommateil ab:

~~~~ {.python}
>>> int(3.99999)
3
>>> int(-2.3)
-2
~~~~

`float` konvertiert Ganzzahlen und Zeichenketten in Fließkommazahlen:

\index{float Funktion}
\index{Funktion!float}

~~~~ {.python}
>>> float(32)
32.0
>>> float('3.14159')
3.14159
~~~~

Schließlich wandelt `str` das Argument in eine Zeichenkette um:

\index{str Funktion}
\index{Funktion!str}

~~~~ {.python}
>>> str(32)
'32'
>>> str(3.14159)
'3.14159'
~~~~

Mathematische Funktionen
------------------------

\index{math Modul}
\index{Modul}
\index{Modul-Objekt}

Python hat ein `math`-Modul, das die meisten der bekannten mathematischen Funktionen bereitstellt. Bevor wir das Modul verwenden können, müssen wir es importieren:

~~~~ {.python}
>>> import math
~~~~

Diese Anweisung erzeugt ein *Modul-Objekt* namens `math`. Wenn Sie das Modulobjekt ausgeben, erhalten Sie einige Informationen über das Objekt:

~~~~ {.python}
>>> print(math)
<module 'math' (built-in)>
~~~~

Das Modulobjekt enthält die im Modul definierten Funktionen und Variablen. Um auf eine der Funktionen zuzugreifen, müssen Sie den Namen des Moduls und den Namen der Funktion angeben, getrennt durch einen Punkt. Dieses Format wird als *Punkt-Notation* (englisch *dot notation*) bezeichnet.

\index{Punkt-Notation}

~~~~ {.python}
>>> ratio = signal_power / noise_power
>>> decibels = 10 * math.log10(ratio)

>>> radians = 0.7
>>> height = math.sin(radians)
~~~~

Im ersten Beispiel wird der Logarithmus zur Basis 10 des Signal-Rausch-Verhältnisses berechnet. Das Mathematikmodul bietet auch eine Funktion namens `log`, die Logarithmen zur Basis e berechnet.

\index{log Funktion}
\index{Funktion!log}
\index{sine Funktion}
\index{trigonometrische Funktion}

Das zweite Beispiel ermittelt den Sinus von `radian`. Der Name der Variablen ist ein Hinweis darauf, dass `sin` und die anderen trigonometrischen Funktionen (`cos`, `tan`, etc.) Argumente im Bogenmaß annehmen. Um von Grad in Bogenmaß umzurechnen, dividieren Sie durch 360 und multiplizieren mit $2 \pi$:

~~~~ {.python}
>>> degrees = 45
>>> radians = degrees / 360.0 * 2 * math.pi
>>> math.sin(radians)
0.7071067811865476
~~~~

Der Ausdruck `math.pi` holt die Variable `pi` aus dem Mathematikmodul. Der Wert dieser Variablen ist eine Näherung von $\pi$, die auf etwa 15 Stellen genau ist.

\index{pi}

Wenn Sie sich in Trigonometrie auskennen, können Sie das vorherige Ergebnis überprüfen, indem Sie es mit der Quadratwurzel aus zwei geteilt durch zwei vergleichen:

\index{sqrt Funktion}
\index{Funktion!sqrt}

~~~~ {.python}
>>> math.sqrt(2) / 2.0
0.7071067811865476
~~~~

Zufallszahlen
-------------

\index{Zufallszahl}
\index{deterministisch}
\index{pseudozufällig}

Bei gleichen Eingaben erzeugen die meisten Computerprogramme jedes Mal die gleichen Ausgaben, weshalb sie als *deterministisch* bezeichnet werden. Determinismus ist normalerweise eine gute Sache, da wir erwarten, dass die gleiche Berechnung das gleiche Ergebnis liefert. Für einige Anwendungen wollen wir jedoch, dass der Computer unvorhersehbar ist. Spiele sind ein offensichtliches Beispiel, aber es gibt noch mehr.

Ein Programm wirklich nicht-deterministisch zu machen, erweist sich als nicht so einfach, aber es gibt Möglichkeiten, es zumindest nicht-deterministisch erscheinen zu lassen. Eine davon ist, *Algorithmen* zu verwenden, die *Pseudozufallszahlen* erzeugen. Pseudozufallszahlen sind nicht wirklich zufällig, da sie durch eine deterministische Berechnung erzeugt werden, aber allein durch das Betrachten der Zahlen ist es nahezu unmöglich, sie von Zufallszahlen zu unterscheiden.

\index{random Modul}
\index{Modul!random}

Das Modul `random` stellt Funktionen zur Verfügung, die Pseudozufallszahlen erzeugen (die von hier an einfach als „zufällig“ bezeichnet werde).

\index{random Funktion}
\index{Funktion!random}

Die Funktion `random` liefert eine zufällige Fließkommazahl zwischen 0,0 und 1,0 (einschließlich 0,0, aber ausschließlich 1,0). Jedes Mal, wenn Sie `random` aufrufen, erhalten Sie die nächste Zahl langen Zufallszahlenfolge. Um ein Beispiel zu sehen, führen Sie diese Schleife aus:

~~~~ {.python}
import random

for i in range(10):
    x = random.random()
    print(x)
~~~~

Dieses Programm erzeugt die folgende Liste von 10 Zufallszahlen zwischen 0,0 und bis zu, aber nicht einschließlich 1,0.

~~~~
0.11132867921152356
0.5950949227890241
0.04820265884996877
0.841003109276478
0.997914947094958
0.04842330803368111
0.7416295948208405
0.510535245390327
0.27447040171978143
0.028511805472785867
~~~~

**Übung 1: Führen Sie das Programm auf Ihrem System aus und schauen Sie, welche Zahlen Sie erhalten. Führen Sie das Programm mehr als einmal aus und sehen Sie, welche Zahlen Sie erhalten.**

Die Funktion `random` ist nur eine von vielen Funktionen, die mit Zufallszahlen umgehen. Die Funktion `randint` nimmt die Parameter `low` und `high` und gibt eine ganze Zahl zwischen `low` und `high` (einschließlich) zurück.

\index{randint Funktion}
\index{Funktion!randint}

~~~~ {.python}
>>> random.randint(5, 10)
5
>>> random.randint(5, 10)
9
~~~~

Um ein Element aus einer Sequenz zufällig auszuwählen, können Sie `choice` verwenden:

\index{choice Funktion}
\index{Funktion!choice}

~~~~ {.python}
>>> t = [1, 2, 3]
>>> random.choice(t)
2
>>> random.choice(t)
3
~~~~

Das Modul `random` bietet auch Funktionen zur Erzeugung von Zufallswerten aus kontinuierlichen Verteilungen wie Gauß, exponentiell, Gamma und ein paar mehr.

Definition neuer Funktionen
---------------------------

Bisher haben wir nur die Funktionen verwendet, die mit Python geliefert werden, aber es ist auch möglich, neue Funktionen hinzuzufügen. Eine *Funktionsdefinition* gibt den Namen einer neuen Funktion und die Reihenfolge der Anweisungen an, die ausgeführt werden, wenn die Funktion aufgerufen wird. Sobald wir eine Funktion definiert haben, können wir die Funktion immer wieder in unserem Programm verwenden.

\index{Funktion}
\index{Funktionsdefinition}
\index{Definition!Funktion}

Here is an example:

~~~~ {.python}
def print_lyrics():
    print("I'm a lumberjack, and I'm okay.")
    print('I sleep all night and I work all day.')
~~~~

`def` ist ein Schlüsselwort, das anzeigt, dass es sich um eine Funktionsdefinition handelt. Der Name der Funktion ist `print_lyrics`. Die Regeln für Funktionsnamen sind die gleichen wie für Variablennamen: Buchstaben, Zahlen und einige Satzzeichen sind zulässig, aber das erste Zeichen darf keine Zahl sein. Sie können kein Schlüsselwort als Funktionsnamen verwenden, und Sie sollten vermeiden, dass eine Variable und eine Funktion denselben Namen haben.

\index{def Schlüsselwort}
\index{Schlüsselwort!def}
\index{Argument}

Die leeren Klammern hinter dem Namen zeigen an, dass diese Funktion keine Argumente annimmt. Später werden wir Funktionen bauen, die Argumente als Eingaben entgegennehmen.

\index{Klammern!leer}
\index{Funktionskopf}
\index{Funktionsrumpf}
\index{Einrückung}
\index{Doppelpunkt}

The first line of the function definition is called the *header*; the rest is called the *body*. The header has to end with a colon and the body has to be indented. By convention, the indentation is always four spaces. The body can contain any number of statements.

Die erste Zeile der Funktionsdefinition wird *Funktionskopf* (englisch *Header*) genannt; der Rest wird *Funktionsrumpf* (englisch *Body*) genannt. Der Funktionskopf muss mit einem Doppelpunkt enden und der Funktionsrumpf muss eingerückt sein. Die Konvention besagt, dass die Einrückung immer vier Leerzeichen beträgt. Der Funktionsrumpf kann eine beliebige Anzahl von Anweisungen enthalten.

\index{Ellipse (Auslassungspunkte)}
\index{Auslassungspunkte (Ellipse)}

Wenn Sie eine Funktionsdefinition im interaktiven Modus eingeben, gibt der Interpreter eine Ellipse `...` (Auslassungspunkte) aus, um Sie darauf hinzuweisen, dass die Definition nicht vollständig ist:

~~~~ {.python}
>>> def print_lyrics():
...     print("I'm a lumberjack, and I'm okay.")
...     print('I sleep all night and I work all day.')
...
~~~~

Um die Funktion zu beenden, müssen Sie eine Leerzeile eingeben (dies ist in einem Skript nicht notwendig).

Das Definieren einer Funktion erzeugt eine Variable mit dem gleichen Namen.

~~~~ {.python}
>>> print(print_lyrics)
<function print_lyrics at 0xb7e99e9c>
>>> print(type(print_lyrics))
<class 'function'>
~~~~

Der Wert von `print_lyrics` ist ein *Funktionsobjekt*, das den Typ `function` hat.

\index{Funktionsobjekt}
\index{Objekt!Funktion}

Die Syntax für den Aufruf der neuen Funktion ist die gleiche wie für integrierte Funktionen:

~~~~ {.python}
>>> print_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
~~~~

Sobald Sie eine Funktion definiert haben, können Sie sie innerhalb einer anderen Funktion verwenden. Um zum Beispiel den vorherigen Refrain zu wiederholen, könnten wir eine Funktion namens `repeat_lyrics` schreiben:

~~~~ {.python}
def repeat_lyrics():
    print_lyrics()
    print_lyrics()
~~~~

Und dann rufen wir `repeat_lyrics` auf:

~~~~ {.python}
>>> repeat_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
~~~~

Aber so geht der Song nicht wirklich.

Definitionen und deren Verwendung
---------------------------------

\index{Funktionsdefinition}

Wenn Sie die Codefragmente aus dem vorherigen Abschnitt zusammenfassen, sieht das gesamte Programm wie folgt aus:

\VerbatimInput{../code3/lyrics.py}

Dieses Programm enthält zwei Funktionsdefinitionen: `print_lyrics` und `repeat_lyrics`. Funktionsdefinitionen werden genau wie andere Anweisungen ausgeführt, aber der Effekt ist, dass Funktionsobjekte erstellt werden. Die Anweisungen innerhalb der Funktion werden erst ausgeführt, wenn die Funktion aufgerufen wird, und die Funktionsdefinition erzeugt keine Ausgabe.

\index{use before def}

Wie Sie vielleicht erwarten, müssen Sie eine Funktion erstellen, bevor Sie sie ausführen können. Mit anderen Worten: Die Funktionsdefinition muss vor dem ersten Aufruf ausgeführt werden.

**Übung 2: Versetzen Sie die letzte Zeile dieses Programms an den Anfang, sodass der Funktionsaufruf vor den Definitionen erscheint. Führen Sie das Programm aus und beobachten Sie, welche Fehlermeldung Sie erhalten.**

**Übung 3: Verschieben Sie den Funktionsaufruf wieder nach unten und verschieben Sie die Definition von `print_lyrics` hinter die Definition von `repeat_lyrics`. Was passiert, wenn Sie dieses Programm ausführen?**

Programmablauf
--------------

\index{Programmablauf}

Um sicherzustellen, dass eine Funktion vor ihrer ersten Verwendung definiert ist, müssen Sie die Reihenfolge kennen, in der Anweisungen ausgeführt werden, was als *Programmablauf* bezeichnet wird.

Die Ausführung beginnt immer mit der ersten Anweisung des Programms. Die Anweisungen werden nacheinander in der Reihenfolge von oben nach unten ausgeführt.

Funktionsdefinitionen verändern den Ablauf des Programms nicht, aber denken Sie daran, dass Anweisungen innerhalb der Funktion erst ausgeführt werden, wenn die Funktion aufgerufen wird.

Ein Funktionsaufruf ist wie ein Umweg im Programmablauf. Anstatt zur nächsten Anweisung zu gehen, springt die Ausführung zum Rumpf der Funktion, führt alle Anweisungen dort aus und kommt dann zurück, um dort weiterzumachen, wo sie aufgehört hat.

Das erscheint solange simpel, bis Sie sich daran erinnern, dass eine Funktion eine andere aufrufen kann. Während sich das Programm mitten in einer Funktion befindet, muss es möglicherweise die Anweisungen einer anderen Funktion ausführen. Aber während diese neue Funktion ausgeführt wird, muss das Programm möglicherweise noch eine andere Funktion ausführen!

Glücklicherweise ist Python gut darin, den Überblick zu behalten, wo es sich befindet. Jedes Mal, wenn eine Funktion abgeschlossen ist, macht das Programm dort weiter, wo es in der Funktion, die es aufgerufen hat, aufgehört hat. Wenn es am Ende des Programms ankommt, *terminiert* es.

Was ist die Moral der Geschichte? Wenn Sie ein Programm lesen, sollten Sie nicht immer von oben nach unten lesen. Manchmal macht es mehr Sinn, wenn Sie dem Programmablauf folgen.

Parameter und Argumente
-----------------------

\index{Parameter}
\index{Funktionsparameter}
\index{Argument}
\index{Funktionsargument}

Einige der eingebauten Funktionen, die wir gesehen haben, benötigen Argumente. Wenn Sie zum Beispiel `math.sin` aufrufen, übergeben Sie eine Zahl als Argument. Einige Funktionen benötigen mehr als ein Argument: `math.pow` benötigt zwei, die Basis und den Exponenten.

Innerhalb der Funktion werden die Argumente Variablen zugewiesen, die *Parameter* genannt werden. Hier ist ein Beispiel für eine benutzerdefinierte Funktion, die ein Argument annimmt:

\index{Klammern!Parameter in}

~~~~ {.python}
def print_twice(bruce):
    print(bruce)
    print(bruce)
~~~~

Diese Funktion weist das Argument einem Parameter namens `bruce` zu. Wenn die Funktion aufgerufen wird, gibt sie den Wert des Parameters (welcher auch immer das ist) zweimal aus.

Diese Funktion funktioniert mit jedem Wert, der ausgegeben werden kann.

~~~~ {.python}
>>> print_twice('Spam')
Spam
Spam
>>> print_twice(17)
17
17
>>> import math
>>> print_twice(math.pi)
3.141592653589793
3.141592653589793
~~~~

Die gleichen Kompositionsregeln, die für integrierte Funktionen gelten, gelten auch für benutzerdefinierte Funktionen, sodass wir jede Art von Ausdruck als Argument für `print_twice` verwenden können:

~~~~ {.python}
>>> print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
>>> print_twice(math.cos(math.pi))
-1.0
-1.0
~~~~

Das Argument wird ausgewertet, bevor die Funktion aufgerufen wird, sodass in den Beispielen die Ausdrücke `'Spam '*4` und `math.cos(math.pi)` nur einmal ausgewertet werden.

\index{Argument}

Sie können auch eine Variable als Argument verwenden:

~~~~ {.python}
>>> michael = 'Eric, the half a bee.'
>>> print_twice(michael)
Eric, the half a bee.
Eric, the half a bee.
~~~~

Der Name der Variablen, die wir als Argument übergeben (`michael`), hat nichts mit dem Namen des Parameters (`bruce`) zu tun. Es spielt keine Rolle, wie der Wert in der aufrufenden Umgebung genannt wurde; hier in `print_twice` heißt der Parameter immer `bruce`.

Funktionen mit und ohne Rückgabewert
------------------------------------

\index{Rückgabewert einer Funktion}
\index{void, Funktion ohne Rückgabewert}
\index{Funktion mit Rückgabewert}
\index{Funktion ohne Rückgabewert, void}

Einige der Funktionen, die wir verwenden, wie z. B. die mathematischen Funktionen, liefern Ergebnisse; in Ermangelung eines besseren Namens nennen wir sie *Funktionen mit Rückgabewert*. Andere Funktionen, wie `print_twice`, führen eine Aktion aus, geben aber keinen Wert zurück. Sie werden *void-Funktionen* genannt.

Wenn Sie eine Funktion mit Rückgabewert aufrufen, wollen Sie fast immer etwas mit dem Ergebnis machen; zum Beispiel können Sie es einer Variablen zuweisen oder als Teil eines Ausdrucks verwenden:

~~~~ {.python}
x = math.cos(radians)
golden = (math.sqrt(5) + 1) / 2
~~~~

Wenn Sie eine Funktion im interaktiven Modus aufrufen, zeigt Python das Ergebnis an:

~~~~ {.python}
>>> math.sqrt(5)
2.23606797749979
~~~~

Aber wenn Sie in einem Skript eine Funktion mit Rückgabewert aufrufen und das Ergebnis der Funktion nicht in einer Variablen speichern, ist der Rückgabewert verloren!

~~~~ {.python}
math.sqrt(5)
~~~~

Dieses Skript berechnet die Quadratwurzel aus 5, aber da es das Ergebnis nicht in einer Variablen speichert oder das Ergebnis anzeigt, ist es nicht sehr nützlich.

\index{interaktiver Modus}
\index{Skript-Modus}

Void-Funktionen können etwas auf dem Bildschirm anzeigen oder einen anderen Effekt haben, aber sie haben keinen Rückgabewert. Wenn Sie versuchen, das Ergebnis einer Variablen zuzuweisen, erhalten Sie einen speziellen Wert namens `None`.

\index{None, Wert}
\index{Wert!None}

~~~~ {.python}
>>> result = print_twice('Bing')
Bing
Bing
>>> print(result)
None
~~~~

Der Wert `None` ist nicht dasselbe wie die Zeichenkette `'None'`. Er ist ein spezieller Wert, der einen eigenen Typ hat:

~~~~ {.python}
>>> print(type(None))
<class 'NoneType'>
~~~~

Um ein Ergebnis aus einer Funktion zurückzugeben, verwenden wir die Anweisung `return` in unserer Funktion. Wir könnten zum Beispiel eine sehr einfache Funktion namens `addtwo` erstellen, die zwei Zahlen addiert und ein Ergebnis zurückgibt.

\VerbatimInput{../code3/addtwo.py}

When this script executes, the `print` statement will print out "8" because the `addtwo` function was called with 3 and 5 as arguments. Within the function, the parameters `a` and `b` were 3 and 5 respectively. The function computed the sum of the two numbers and placed it in the local function variable named `added`. Then it used the `return` statement to send the computed value back to the calling code as the function result, which was assigned to the variable `x` and printed out.

Wenn dieses Skript ausgeführt wird, wird `print` `'8'` ausgeben, weil die Funktion `addtwo` mit 3 und 5 als Argumente aufgerufen wurde. Innerhalb der Funktion waren die Parameter `a` und `b` jeweils 3 und 5. Die Funktion berechnete die Summe der beiden Zahlen und legte sie in der lokalen Funktionsvariablen namens `added` ab. Dann gab sie den berechneten Wert mit der Anweisung `return` als Funktionsergebnis an die aufrufende Umgebung zurück, die der Variablen `x` zugewiesen und ausgegeben wurde.

Wozu Funktionen?
----------------

\index{Funktionen}

Es ist vielleicht nicht sofort klar, warum es die Mühe wert ist, ein Programm in Funktionen zu unterteilen. Aber dafür gibt es mehrere Gründe:

-   Das Erstellen einer neuen Funktion gibt Ihnen die Möglichkeit, eine Gruppe von Anweisungen zu benennen, wodurch Ihr Programm leichter zu lesen, zu verstehen und zu debuggen ist.

-   Funktionen können ein Programm kleiner machen, indem sie sich wiederholenden Code eliminieren. Wenn Sie später eine Änderung vornehmen, müssen Sie diese nur an einer Stelle vornehmen.

-   Wenn Sie ein langes Programm in Funktionen aufteilen, können Sie die Teile einzeln debuggen und sie dann zu einem funktionierenden Ganzen zusammensetzen.

-   Gut durchdachte Funktionen sind oft für viele Programme nützlich. Wenn Sie einmal eine geschrieben und debuggt haben, können Sie sie wiederverwenden.

Throughout the rest of the book, often we will use a function definition to explain a concept. Part of the skill of creating and using functions is to have a function properly capture an idea such as "find the smallest value in a list of values". Later we will show you code that finds the smallest in a list of values and we will present it to you as a function named `min` which takes a list of values as its argument and returns the smallest value in the list.

Im weiteren Verlauf des Buchs werden wir oft eine Funktionsdefinition verwenden, um ein Konzept zu erklären. Ein Teil der Fertigkeit beim Erstellen und Verwenden von Funktionen besteht darin, dass eine Funktion eine Idee wie „finde den kleinsten Wert in einer Liste von Werten“ richtig erfasst. Später werden wir Ihnen Code zeigen, der den kleinsten Wert in einer Liste findet, und wir werden Ihnen diesen Code als eine Funktion namens `min` vorstellen, die eine Liste von Werten als Argument entgegennimmt und den kleinsten Wert dieser Liste zurückgibt.

Debugging
---------

\index{Debugging}

Wenn Sie einen Texteditor zum Schreiben Ihrer Skripte verwenden, kann es zu Problemen mit Leerzeichen und Tabulatoren kommen. Der beste Weg, diese Probleme zu vermeiden, ist, ausschließlich Leerzeichen zu verwenden (keine Tabulatoren). Die meisten Texteditoren, die sich mit Python auskennen, tun dies standardmäßig, manche aber auch nicht.

\index{Whitespace}

Tabulatoren und Leerzeichen sind normalerweise unsichtbar, was die Fehlersuche erschwert. Versuchen Sie daher, einen Editor zu finden, der die Einrückung für Sie automatisch vornimmt.

Vergessen Sie auch nicht, Ihr Programm zu speichern, bevor Sie es ausführen. Manche Entwicklungsumgebungen tun dies automatisch, manche aber auch nicht. In diesem Fall ist das Programm, das Sie sich im Texteditor ansehen, nicht dasselbe wie das Programm, das Sie ausführen. Die Fehlersuche kann sehr lange dauern, wenn Sie das gleiche fehlerhafte Programm immer und immer wieder ausführen! Vergewissern Sie sich, dass der Code, den Sie sich ansehen, auch der Code ist, den Sie ausführen. Wenn Sie sich nicht sicher sind, fügen Sie etwas wie `print("hello")` an den Anfang des Programms und führen Sie es erneut aus. Wenn Sie kein `hello` sehen, führen Sie nicht das richtige Programm aus!

Glossar
-------

Algorithmus
:   Ein allgemeines Verfahren zum Lösen einer Kategorie von Problemen.
\index{Algorithmus}

Argument
:   Ein Wert, der einer Funktion zur Verfügung gestellt wird, wenn die Funktion aufgerufen wird. Dieser Wert wird dem entsprechenden Parameter in der Funktion zugewiesen.
\index{Argument}

Funktionsrumpf
:   Die Folge von Anweisungen innerhalb einer Funktionsdefinition.
\index{Funktionsrumpf}

deterministisch
:   Bezieht sich auf ein Programm, das bei jedem Durchlauf das Gleiche tut, wenn es die gleichen Eingaben hat.
\index{deterministisch}

Punkt-Notation
:   Die Syntax für den Aufruf einer Funktion in einem anderen Modul durch Angabe des Modulnamens, gefolgt von einem Punkt und dem Funktionsnamen.
\index{Punkt-Notation}

Programmablauf
:   Die Reihenfolge, in der Anweisungen während eines Programmlaufs ausgeführt werden.
\index{Programmablauf}

Funktion
:   Eine benannte Folge von Anweisungen, die eine nützliche Operation ausführt. Funktionen können Argumente annehmen oder nicht und können ein Ergebnis erzeugen oder nicht.
\index{Funktion}

Funktionsaufruf
:   Eine Anweisung, die eine Funktion ausführt. Sie besteht aus dem Funktionsnamen, gefolgt von einer Argumentliste.
\index{Funktionsaufruf}

Funktionsdefinition
:   Eine Anweisung, die eine neue Funktion erstellt und ihren Namen, ihre Parameter und die Anweisungen, die sie ausführt, angibt.
\index{Funktionsdefinition}

Funktionsobjekt
:   Ein Wert, der durch eine Funktionsdefinition erzeugt wird. Der Name der Funktion ist eine Variable, die auf ein Funktionsobjekt verweist.
\index{Funktionsobjekt}

Funktionskopf
:   Die erste Zeile einer Funktionsdefinition.
\index{Funktionskopf}

Importanweisung
:   Eine Anweisung, die eine Moduldatei liest und ein Modulobjekt erstellt.
\index{Importanweisung}
\index{Anweisung!Import}

Modul-Objekt
:   Ein durch eine `import`-Anweisung erzeugter Wert, der den Zugriff auf die in einem Modul definierten Daten und den Code ermöglicht.
\index{Modul-Objekt}

Parameter
:   Ein Name, der innerhalb einer Funktion verwendet wird, um auf den als Argument übergebenen Wert zu verweisen.
\index{Parameter}

pseudozufällig
:   Bezieht sich auf eine Folge von Zahlen, die nur scheinbar zufällig sind, aber von einem deterministischen Programm erzeugt werden.
\index{pseudozufällig}

Rückgabewert
:   Das Ergebnis einer Funktion. Wenn ein Funktionsaufruf als Ausdruck verwendet wird, ist der Rückgabewert der Wert des Ausdrucks.
\index{Rückgabewert}

void, Funktion ohne Rückgabewert
:   Eine Funktion, die keinen Wert zurückgibt.
\index{void, Funktion ohne Rückgabewert}

Übungen
-------

**Übung 4: Was ist der Zweck des Schlüsselworts `def` in Python?**

a\) Es ist Slang und bedeutet „der folgende Code ist wirklich cool“\
b) Es zeigt den Beginn einer Funktion an\
c) Es zeigt an, dass der folgende eingerückte Codeabschnitt für später gespeichert werden soll\
d) b und c sind beide wahr\
e) Keiner der oben genannten Punkte

**Übung 5: Was wird das folgende Python-Programm ausgeben?**

~~~~ {.python}
def fred():
   print("Zap")

def jane():
   print("ABC")

jane()
fred()
jane()
~~~~

a\) Zap ABC jane fred jane\
b) Zap ABC Zap\
c) ABC Zap jane\
d) ABC Zap ABC\
e) Zap Zap Zap

**Übung 6: Schreiben Sie ihr Programm zur Lohnberechnung (mit 1,4-fachem Stundenlohn bei Überstunden) um. Ergänzen Sie eine Funktion `computepay`, welche die beiden Parameter `hours` und `rate` entgegennimmt**

~~~~
Enter Hours: 45
Enter Rate: 10
Pay: 475.0
~~~~

**Übung 7: Schreiben Sie das Benotungsprogramm aus dem vorigen Kapitel neu, indem Sie eine Funktion namens `computegrade` verwenden, die eine Punktzahl als Parameter annimmt und eine Note als Zeichenkette zurückgibt.**

~~~~
 Score   Grade
>= 0.9     A
>= 0.8     B
>= 0.7     C
>= 0.6     D
 < 0.6     F
~~~~

~~~~
Enter score: 0.95
A
~~~~

~~~~
Enter score: perfect
Bad score
~~~~

~~~~
Enter score: 10.0
Bad score
~~~~

~~~~
Enter score: 0.75
C
~~~~

~~~~
Enter score: 0.5
F
~~~~

Führen Sie das Programm wiederholt aus, um die verschiedenen Werte für die Eingabe zu testen.

